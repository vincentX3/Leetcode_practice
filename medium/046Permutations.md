# 46. Permutations

```

Given a collection of distinct integers, return all possible permutations.

Example:

Input: [1,2,3]
Output:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

## Notes

生成无重复集合元素的全排列，从回溯法的角度，便是通过DFS创建一颗子集树。  
具体实现，可以从两个角度思考：

1. 插入法
想要生成`n`个元素的全排列，只需要将$n_i$插入`n-1`个元素全排列的每个位置即可。  
具体实现，可以用一个`queue` 存储上一轮的排列，缺点也在于空间开销。 

2. 交换法
思考，怎样才是不同的排列？  
一句废话：第i位元素不同的两个排列，即是不同的排列。
那么，我们可以通过递归来缩减问题规模，生成排列。  
具体而言，即是研究第`i`位元素，我们有`swap(i,j)`，`j=[i:len(nums)]`，保证了第`i`位元素不同后，就递归研究`i+1`位元素即可。
